<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>图片标注工具</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div class="container">
      <h1>图片标注工具</h1>
      <div id="app"></div>
    </div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useRef, useEffect, useMemo } = React;
      // 设置canvas默认尺寸
      const DEFAULT_WIDTH = 800;
      const DEFAULT_HEIGHT = 600;
      const ImageAnnotation = ({ src }) => {
        const [annotations, setAnnotations] = useState([]);
        const [history, setHistory] = useState([]);
        const [currentTool, setCurrentTool] = useState(null);
        const [isDrawing, setIsDrawing] = useState(false);
        const [isDragging, setIsDragging] = useState(false);
        const [startPos, setStartPos] = useState({ x: 0, y: 0 });
        const [currentPos, setCurrentPos] = useState({ x: 0, y: 0 });
        const [freehandPath, setFreehandPath] = useState([]); // 存储自由绘制路径点
        const [textInput, setTextInput] = useState({
          show: false,
          x: 0,
          y: 0,
          width: 200, // 默认文本框宽度
          height: 24, // 默认文本框高度
          text: "",
          editId: null, // 正在编辑的标注ID
        });
        const [status, setStatus] = useState("请选择工具开始标注");
        const [selectedId, setSelectedId] = useState(null);
        const canvasRef = useRef(null);
        const imageRef = useRef(null);
        const textAreaRef = useRef(null);

        const textAreaTop = useMemo(() => {
          return textInput.y - textInput.height / 2 <= 10
            ? 10
            : textInput.y - textInput.height / 2;
        }, [textInput]);

        const download = () => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const dataUrl = canvas.toDataURL("image/png");
          const a = document.createElement("a");
          a.href = dataUrl;
          a.download = "annotated_image.png";
          a.click();
          a.remove();
        };

        // 开始文字输入
        const startTextInput = (x, y, editId = null) => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const ctx = canvas.getContext("2d");
          ctx.font = "16px Arial";

          let text = "";
          let width = 200;
          let height = 24;

          if (editId) {
            const annotation = annotations.find((a) => a.id === editId);
            if (annotation) {
              text = annotation.text;
              // 计算多行文本的尺寸
              const lines = text.split("\n");
              height = Math.max(24, lines.length * 20);
              width =  Math.max(...lines.map((line) => ctx.measureText(line).width)) + 10;
            }
          }
          setTextInput({
            show: true,
            x,
            y,
            width,
            height,
            text,
            editId,
          });
        }; // 完成文字输入
        const finishTextInput = () => {
          const text = textInput.text.trim();
          if (!text) {
            setTextInput({ ...textInput, show: false });
            return;
          }

          if (textInput.editId) {
            // 编辑现有文字
            setAnnotations((prev) =>
              prev.map((ann) =>
                ann.id === textInput.editId
                  ? {
                      ...ann,
                      text,
                      // 保持原始位置不变
                      x: ann.x,
                      y: ann.y,
                    }
                  : ann
              )
            );
          } else {
            // 添加新文字
            saveHistory();
            const canvas = canvasRef.current;
            if (canvas) {
              const ctx = canvas.getContext("2d");
              ctx.font = "16px Arial";
              // 确保文字位置在合理范围内
              const x = Math.max(0, Math.min(textInput.x, canvas.width - 200));
              const y = Math.max(16, Math.min(textInput.y, canvas.height - 10));

              setAnnotations((prev) => [
                ...prev,
                {
                  id: `${prev.length + 1}`,
                  type: "text",
                  x,
                  y,
                  text,
                  color: "#FF0000",
                },
              ]);
            }
          }
          setTextInput({ ...textInput, show: false });
        };

        const handleTextChange = (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const ctx = canvas.getContext("2d");
          ctx.font = "16px Arial";

          // 计算最大可用尺寸（考虑canvas边界）
          const maxWidth = Math.max(10, canvas.width - textInput.x - 10); // 保留10px边距
          const maxHeight = Math.max(24, canvas.height - textInput.y - 10); // 最小高度24px

          const input = e.target.value;
          const lines = input.split("\n");

          // 计算每行宽度和总高度
          let totalHeight = 0;
          let maxLineWidth = 0;
          const lineMetrics = lines.map((line) => {
            const metrics = ctx.measureText(line);
            const lineWidth = Math.min(metrics.width, maxWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
            totalHeight += 20; // 行高固定为20px
            return {
              line,
              width: lineWidth,
            };
          });

          // 计算最终文本区域尺寸
          const taWidth = maxLineWidth + 10; // 加10px边距
          const taHeight = Math.min(totalHeight, maxHeight);

          // 如果达到高度限制，截断文本
          let finalText = input;
          if (totalHeight > maxHeight) {
            const maxLines = Math.floor(maxHeight / 20);
            finalText = lines.slice(0, maxLines).join("\n");
          }

          setTextInput({
            ...textInput,
            text: finalText,
            width: taWidth,
            height: taHeight,
          });
        };

        // 保存历史记录
        const saveHistory = () => {
          setHistory((prev) => [...prev, [...annotations]]);
        };

        // 回退上一步
        const undo = () => {
          if (history.length > 0) {
            const lastState = history[history.length - 1];
            setHistory((prev) => prev.slice(0, -1));
            setAnnotations(lastState);
            setSelectedId(null);
            setStatus(`已回退上一步操作 (剩余 ${history.length - 1} 步历史)`);
          }
        };

        // 删除选中元素
        const deleteSelected = () => {
          if (selectedId) {
            saveHistory();
            setAnnotations((prev) => prev.filter((a) => a.id !== selectedId));
            setSelectedId(null);
            setStatus("已删除选中标注");
          }
        };

        // 绘制箭头函数
        const drawArrow = (ctx, fromX, fromY, toX, toY, color) => {
          const headLength = 15;
          const angle = Math.atan2(toY - fromY, toX - fromX);

          ctx.strokeStyle = color;
          ctx.lineWidth = 2;

          // 箭杆
          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();

          // 箭头
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(
            toX - headLength * Math.cos(angle - Math.PI / 6),
            toY - headLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.moveTo(toX, toY);
          ctx.lineTo(
            toX - headLength * Math.cos(angle + Math.PI / 6),
            toY - headLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.stroke();
        };

        // 绘制控制点
        const drawControlPoint = (
          ctx,
          x,
          y,
          color1 = "#FF0000",
          color2 = "#FFFFFF"
        ) => {
          ctx.fillStyle = color2;
          ctx.strokeStyle = color1;
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        };

        // 获取标注的外接矩形
        const getBoundingBox = (ann, ctx) => {
          if (ann.type === "rectangle") {
            return {
              x: ann.x,
              y: ann.y,
              width: ann.width,
              height: ann.height,
            };
          } else if (ann.type === "circle") {
            return {
              x: ann.x - ann.radius,
              y: ann.y - ann.radius,
              width: ann.radius * 2,
              height: ann.radius * 2,
            };
          } else if (ann.type === "arrow") {
            // 计算箭头的外接矩形
            const minX = Math.min(ann.x, ann.x + ann.width);
            const minY = Math.min(ann.y, ann.y + ann.height);
            const maxX = Math.max(ann.x, ann.x + ann.width);
            const maxY = Math.max(ann.y, ann.y + ann.height);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY,
            };
          } else if (ann.type === "text") {
            ctx.font = "16px Arial";
            const lines = ann.text.split("\n");
            const lineHeight = 20; // 行高
            const totalHeight = lines.length * lineHeight;

            // 计算最长行的宽度
            let maxWidth = 0;
            lines.forEach((line) => {
              const metrics = ctx.measureText(line);
              maxWidth = Math.max(maxWidth, metrics.width);
            });
            return {
              x: ann.x,
              y: ann.y - lineHeight,
              width: maxWidth,
              height: totalHeight,
            };
          }
          return { x: 0, y: 0, width: 0, height: 0 };
        };

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          canvas.width = DEFAULT_WIDTH;
          canvas.height = DEFAULT_HEIGHT;
          const img = new Image();
          img.crossOrigin = "Anonymous"; // 处理跨域问题
          img.src = src;
          img.onload = () => {
            imageRef.current = img;
            drawCanvas();
          };

          const resizeCanvas = () => {
            // 只需要调整CSS显示尺寸，保持原始画布尺寸不变
            const container = canvas.parentElement;
            if (container) {
              const ratio = img.width / img.height;
              const maxWidth = container.clientWidth;
              canvas.style.width = `${Math.min(maxWidth, img.width)}px`;
              canvas.style.height = `${Math.min(
                maxWidth / ratio,
                img.height
              )}px`;
            }
          };

          window.addEventListener("resize", resizeCanvas);
          return () => window.removeEventListener("resize", resizeCanvas);
        }, [src]);

        // 绘制画布
        const drawCanvas = () => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext("2d");
          if (!ctx) return;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (imageRef.current) {
            // 计算等比例缩放尺寸
            const ratio = Math.min(
              DEFAULT_WIDTH / imageRef.current.naturalWidth,
              DEFAULT_HEIGHT / imageRef.current.naturalHeight
            );
            const displayWidth = imageRef.current.naturalWidth * ratio;
            const displayHeight = imageRef.current.naturalHeight * ratio;

            // 居中绘制图片
            const offsetX = (DEFAULT_WIDTH - displayWidth) / 2;
            const offsetY = (DEFAULT_HEIGHT - displayHeight) / 2;

            ctx.drawImage(
              imageRef.current,
              offsetX,
              offsetY,
              displayWidth,
              displayHeight
            );

            // 保存缩放和偏移信息用于坐标转换
            canvas.dataset.scale = ratio;
            canvas.dataset.offsetX = offsetX;
            canvas.dataset.offsetY = offsetY;
          }

          // 绘制自由绘制路径
          if (
            isDrawing &&
            currentTool === "freehand" &&
            freehandPath.length > 1
          ) {
            ctx.strokeStyle = "#FF0000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(freehandPath[0].x, freehandPath[0].y);
            for (let i = 1; i < freehandPath.length; i++) {
              ctx.lineTo(freehandPath[i].x, freehandPath[i].y);
            }
            ctx.stroke();
          }
          console.log('draw canvas');
          
          // 绘制已有标注
          annotations.forEach((ann) => {
            ctx.strokeStyle = ann.color;
            ctx.lineWidth = 2;

            if (ann.type === "rectangle") {
              ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
            } else if (ann.type === "circle") {
              ctx.beginPath();
              ctx.arc(ann.x, ann.y, ann.radius, 0, Math.PI * 2);
              ctx.stroke();
            } else if (ann.type === "arrow") {
              drawArrow(
                ctx,
                ann.x,
                ann.y,
                ann.x + ann.width,
                ann.y + ann.height,
                ann.color
              );
            } else if (ann.type === "text") {
              if (textInput.show && textInput.editId === ann.id) {
                return;
              }
              ctx.fillStyle = ann.color;
              ctx.font = "16px Arial";
              // 处理多行文字渲染
              const lines = ann.text.split("\n");
              let yPos = ann.y;
              lines.forEach((line) => {
                ctx.fillText(line, ann.x, yPos);
                yPos += 20; // 行间距
              });
            } else if (ann.type === "freehand" && ann.points.length > 1) {
              ctx.strokeStyle = ann.color;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(ann.points[0].x, ann.points[0].y);
              for (let i = 1; i < ann.points.length; i++) {
                ctx.lineTo(ann.points[i].x, ann.points[i].y);
              }
              ctx.stroke();
            }

            // 绘制选中状态, 自由绘制和文字除外
            if (
              ann.id === selectedId &&
              ann.type !== "freehand" &&
              ann.type !== "text"
            ) {
              const boundingBox = getBoundingBox(ann, ctx);

              if (ann.type === "arrow") {
                // 只绘制两端控制点
                drawControlPoint(ctx, ann.x, ann.y);
                drawControlPoint(ctx, ann.x + ann.width, ann.y + ann.height);
              } else {
                // 其他类型绘制外接框和控制点
                ctx.setLineDash([3, 3]);
                ctx.strokeStyle = "#1890ff";
                ctx.strokeRect(
                  boundingBox.x,
                  boundingBox.y,
                  boundingBox.width,
                  boundingBox.height
                );
                ctx.setLineDash([]);

                // 绘制控制点
                drawControlPoint(ctx, boundingBox.x, boundingBox.y);
                drawControlPoint(
                  ctx,
                  boundingBox.x + boundingBox.width,
                  boundingBox.y
                );
                drawControlPoint(
                  ctx,
                  boundingBox.x + boundingBox.width,
                  boundingBox.y + boundingBox.height
                );
                drawControlPoint(
                  ctx,
                  boundingBox.x,
                  boundingBox.y + boundingBox.height
                );
              }
            }
          });

          // 绘制当前标注
          if (isDrawing && currentTool) {
            ctx.strokeStyle = "#FF0000";
            ctx.lineWidth = 2;

            const width = currentPos.x - startPos.x;
            const height = currentPos.y - startPos.y;

            if (currentTool === "rectangle") {
              ctx.strokeRect(startPos.x, startPos.y, width, height);
            } else if (currentTool === "circle") {
              const radius = Math.sqrt(width * width + height * height);
              ctx.beginPath();
              ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2);
              ctx.stroke();
            } else if (currentTool === "arrow") {
              if (Math.abs(width) > 5 || Math.abs(height) > 5) {
                drawArrow(
                  ctx,
                  startPos.x,
                  startPos.y,
                  currentPos.x,
                  currentPos.y,
                  "#FF0000"
                );
              }
            }
          }
        };

        // 检测点击是否在控制点上
        const isInControlPoint = (ann, x, y, ctx) => {
          if (ann.type === "freehand") return false;
          const boundingBox = getBoundingBox(ann, ctx);

          return (
            (Math.abs(x - boundingBox.x) < 6 &&
              Math.abs(y - boundingBox.y) < 6) ||
            (Math.abs(x - (boundingBox.x + boundingBox.width)) < 6 &&
              Math.abs(y - boundingBox.y) < 6) ||
            (Math.abs(x - (boundingBox.x + boundingBox.width)) < 6 &&
              Math.abs(y - (boundingBox.y + boundingBox.height)) < 6) ||
            (Math.abs(x - boundingBox.x) < 6 &&
              Math.abs(y - (boundingBox.y + boundingBox.height)) < 6)
          );
        };

        function isPointNearLine(x, y, x1, y1, x2, y2, threshold = 6) {
          // 计算点到线段的最短距离
          const A = x - x1;
          const B = y - y1;
          const C = x2 - x1;
          const D = y2 - y1;
          const dot = A * C + B * D;
          const len_sq = C * C + D * D;
          let param = -1;
          if (len_sq !== 0) param = dot / len_sq;
          let xx, yy;
          if (param < 0) {
            xx = x1;
            yy = y1;
          } else if (param > 1) {
            xx = x2;
            yy = y2;
          } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
          }
          const dx = x - xx;
          const dy = y - yy;
          return Math.sqrt(dx * dx + dy * dy) < threshold;
        }

        // 检测点击是否在标注上
        const isInAnnotation = (ann, x, y, ctx) => {
          if (textInput.show && textInput.editId === ann.id) return false;
          if (ann.type === "rectangle") {
            // 判断点是否在矩形边框上
            const lineWidth = 2; // 匹配绘制时的线宽
            return (
              (Math.abs(x - ann.x) <= lineWidth &&
                y >= ann.y &&
                y <= ann.y + ann.height) || // 左边线
              (Math.abs(x - (ann.x + ann.width)) <= lineWidth &&
                y >= ann.y &&
                y <= ann.y + ann.height) || // 右边线
              (Math.abs(y - ann.y) <= lineWidth &&
                x >= ann.x &&
                x <= ann.x + ann.width) || // 上边线
              (Math.abs(y - (ann.y + ann.height)) <= lineWidth &&
                x >= ann.x &&
                x <= ann.x + ann.width) // 下边线
            );
          } else if (ann.type === "circle") {
            // 判断点是否在圆周上（考虑线宽）
            const distance = Math.sqrt((x - ann.x) ** 2 + (y - ann.y) ** 2);
            return Math.abs(distance - ann.radius) <= 2; // 2px误差范围
          } else if (ann.type === "arrow") {
            // 使用原有的线段判断方法
            return isPointNearLine(
              x,
              y,
              ann.x,
              ann.y,
              ann.x + ann.width,
              ann.y + ann.height
            );
          } else if (ann.type === "text") {
            // 文字保持原有判断方式
            const boundingBox = getBoundingBox(ann, ctx);
            return (
              x >= boundingBox.x &&
              x <= boundingBox.x + boundingBox.width &&
              y >= boundingBox.y &&
              y <= boundingBox.y + boundingBox.height
            );
          } else if (ann.type === "freehand") {
            for (let i = 0; i < ann.points.length - 1; i++) {
              const isNearLine = isPointNearLine(
                x,
                y,
                ann.points[i].x,
                ann.points[i].y,
                ann.points[i + 1].x,
                ann.points[i + 1].y
              );
              if (isNearLine) {
                return true;
              }
            }
            return false;
          }
          return false;
        };

        const handleMouseDown = (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const ctx = canvas.getContext("2d");

          // 检查是否双击文字进行编辑
          if (e.detail === 2) {
            const clickedText = annotations.find(
              (a) => a.type === "text" && isInAnnotation(a, x, y, ctx)
            );
            if (clickedText) {
              startTextInput(clickedText.x, clickedText.y, clickedText.id);
              return;
            }
          }

          // 如果正在输入文字，点击外部完成输入
          if (textInput.show) {
            if(!textInput.text) {
              startTextInput(x, y);
            } else {
              finishTextInput();
            }
            return;
          }
          // 处理文字工具
          if (currentTool === "text") {
            startTextInput(x, y);
            return;
          }
          // 右键取消选择
          if (e.button === 2) {
            setSelectedId(null);
            return;
          }

          // 首先检查是否点击了自由绘制线条（优先于其他检查）
          const clickedFreehand = [...annotations]
            .reverse()
            .find(
              (ann) => ann.type === "freehand" && isInAnnotation(ann, x, y, ctx)
            );
          if (clickedFreehand) {
            setIsDragging(true);
            setSelectedId(clickedFreehand.id);
            setStartPos({ x, y });
            setCurrentPos({ x, y });
            return;
          }

          // 检查是否点击了已有标注的控制点（优先处理选中元素的操作）
          if (selectedId) {
            const selectedAnn = annotations.find((a) => a.id === selectedId);
            if (selectedAnn) {
              // 先检查控制点
              if (isInControlPoint(selectedAnn, x, y, ctx)) {
                setIsDrawing(true);
                setStartPos({ x, y });
                setCurrentPos({ x, y });
                return;
              }

              // 再检查是否在标注本身上
              if (isInAnnotation(selectedAnn, x, y, ctx)) {
                setIsDragging(true);
                setStartPos({ x, y });
                setCurrentPos({ x, y });
                return;
              }
            }
          }

          // 检查是否点击了其他标注（非当前选中标注）
          const clickedAnnotation = [...annotations]
            .reverse()
            .find(
              (ann) => ann.id !== selectedId && isInAnnotation(ann, x, y, ctx)
            );

          if (clickedAnnotation) {
            setSelectedId(clickedAnnotation.id);
            return;
          }

          // 如果点击空白处且没有选中任何内容，则取消当前选择
          if (selectedId) {
            setSelectedId(null);
          }

          // 只有点击空白处且没有选中任何内容时，才启用绘制功能
          if (!currentTool) return;

          if (currentTool === "freehand") {
            setFreehandPath([{ x, y }]);
          }
          setIsDrawing(true);
          setStartPos({ x, y });
          setCurrentPos({ x, y });
          setStatus(
            `正在绘制 ${currentTool} (起点: ${x.toFixed(0)}, ${y.toFixed(0)})`
          );
        };
        const handleMouseMove = (e) => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const ctx = canvas.getContext("2d");

          // 检查是否在任意标注上
          const isOnAnnotation = annotations.some((ann) =>
            isInAnnotation(ann, x, y, ctx)
          );
          canvas.style.cursor = isOnAnnotation ? "move" : "crosshair";

          // 拖动整个标注
          if (isDragging && selectedId) {
            const dx = x - currentPos.x;
            const dy = y - currentPos.y;

            setAnnotations((prev) =>
              prev.map((ann) => {
                if (ann.id === selectedId) {
                  if (ann.type === "freehand") {
                    return {
                      ...ann,
                      points: ann.points.map((point) => ({
                        x: point.x + dx,
                        y: point.y + dy,
                      })),
                    };
                  } else {
                    return { ...ann, x: ann.x + dx, y: ann.y + dy };
                  }
                }
                return ann;
              })
            );

            setCurrentPos({ x, y });
            drawCanvas();
            return;
          }

          // 自由绘制处理
          if (isDrawing && currentTool === "freehand") {
            setFreehandPath((prev) => [...prev, { x, y }]);
            drawCanvas();
            return;
          }

          // 绘制新标注或调整控制点
          if (isDrawing) {
            setCurrentPos({ x, y });
            setStatus(
              `正在绘制 ${currentTool} (起点: ${startPos.x.toFixed(
                0
              )}, ${startPos.y.toFixed(0)}) → (终点: ${x.toFixed(
                0
              )}, ${y.toFixed(0)})`
            );
            drawCanvas();
          }
        };

        const handleMouseUp = () => {
          if (!isDrawing && !isDragging) return;

          // 自由绘制的结束处理
          if (currentTool === "freehand" && freehandPath.length > 1) {
            saveHistory();
            setAnnotations((prev) => [
              ...prev,
              {
                id: `${prev.length + 1}`,
                type: "freehand",
                points: [...freehandPath],
                color: "#FF0000",
              },
            ]);
            setFreehandPath([]);
            setStatus(`已添加自由绘制线条 (共 ${annotations.length + 1} 个)`);
          }

          setIsDrawing(false);
          setIsDragging(false);

          if (isDragging) {
            saveHistory();
            setStatus("已移动选中标注");
            return;
          }

          if (!currentTool) return;

          const width = currentPos.x - startPos.x;
          const height = currentPos.y - startPos.y;

          // 只有距离足够时才添加
          if (Math.abs(width) > 5 || Math.abs(height) > 5) {
            saveHistory();
            const newAnnotation = {
              id: `${annotations.length + 1}`,
              type: currentTool,
              x: startPos.x,
              y: startPos.y,
              width,
              height,
              radius:
                currentTool === "circle"
                  ? Math.sqrt(width * width + height * height)
                  : undefined,
              color: "#FF0000",
            };

            setAnnotations((prev) => [...prev, newAnnotation]);
            setStatus(
              `已添加 ${currentTool} 标注 (共 ${annotations.length + 1} 个)`
            );
          } else {
            setStatus("绘制距离太短，已取消");
          }
        };

        const clearCanvas = () => {
          saveHistory();
          setAnnotations([]);
          setSelectedId(null);
          setStatus("已清除所有标注");
        };
        // textarea auto focus
        useEffect(() => {
          if (textInput.show && textAreaRef.current) {
            textAreaRef.current.focus();
            const len = textAreaRef.current.value.length;
            textAreaRef.current.setSelectionRange(len, len);
          }
        }, [textInput.show, textInput.x]);

        useEffect(() => {
          if (!isDragging || !isDrawing) {
            drawCanvas();
          }
          // 设置选中状态下的鼠标样式
          const canvas = canvasRef.current;
          if (canvas) {
            canvas.style.cursor = selectedId ? "move" : "crosshair";
          }
        }, [annotations, selectedId, isDragging, isDrawing]);

        useEffect(() => {
          if (selectedId && currentTool !== "freehand") {
            setSelectedId(null);
          }
          if(textInput.show) {
            finishTextInput();
          }
        }, [currentTool]);

        return (
          <div>
            <div className="toolbar">
              <button
                className={currentTool === "rectangle" ? "active" : ""}
                onClick={() => setCurrentTool("rectangle")}
              >
                矩形
              </button>
              <button
                className={currentTool === "circle" ? "active" : ""}
                onClick={() => setCurrentTool("circle")}
              >
                圆形
              </button>
              <button
                className={currentTool === "arrow" ? "active" : ""}
                onClick={() => setCurrentTool("arrow")}
              >
                箭头
              </button>
              <button
                className={currentTool === "text" ? "active" : ""}
                onClick={() => setCurrentTool("text")}
              >
                文字
              </button>
              <button
                className={currentTool === "freehand" ? "active" : ""}
                onClick={() => setCurrentTool("freehand")}
              >
                自由线条
              </button>
              <button
                onClick={clearCanvas}
                style={{
                  marginLeft: "20px",
                  background: "#ff4d4f",
                  color: "white",
                }}
              >
                清除所有
              </button>
              <button
                onClick={undo}
                disabled={history.length === 0}
                style={{ marginLeft: "10px" }}
              >
                撤销 (Ctrl+Z)
              </button>
              <button onClick={download} style={{ marginLeft: "10px" }}>
                导出
              </button>
            </div>

            <div className="image-container">
              <canvas
                ref={canvasRef}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
              />
              {textInput.show && (
                <textarea
                  ref={textAreaRef}
                  className="text-input"
                  style={{
                    left: textInput.x,
                    top: textAreaTop,
                    width: textInput.width,
                    height: textInput.height,
                  }}
                  value={textInput.text}
                  onChange={handleTextChange}
                />
              )}
            </div>
            <div className="status">{status}</div>
            <div>
              <h3>当前标注 ({annotations.length}个):</h3>
              <pre>{JSON.stringify(annotations, null, 2)}</pre>
            </div>
          </div>
        );
      };

      const App = () => {
        return (
          <ImageAnnotation src="https://img1.baa.bitautotech.com/dzusergroupfiles/2024/11/06/e2a4e9bb9e854429bed46ba1e343b47a.jpg" />
        );
      };

      ReactDOM.render(<App />, document.getElementById("app"));
    </script>
  </body>
</html>
